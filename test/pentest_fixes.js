#!/usr/bin/env node
/**
 * Final audit: tests all security fixes from the pentest round.
 * Verifies endpoints still work AND that vulnerabilities are closed.
 */

const BASE = process.env.API_URL || 'http://localhost:3000/v1';
let pass = 0, fail = 0, skip = 0;
const results = [];

async function req(method, path, { body, headers = {} } = {}) {
  const opts = { method, headers: { 'Accept': 'application/json', ...headers } };
  if (body) {
    opts.headers['Content-Type'] = 'application/json';
    opts.body = JSON.stringify(body);
  }
  opts.signal = AbortSignal.timeout(10000);
  const res = await fetch(`${BASE}${path}`, opts);
  let data;
  try { data = await res.json(); } catch { data = null; }
  return { status: res.status, data };
}

function test(name, passed, detail) {
  if (passed) { pass++; results.push(`  ✓ ${name}`); }
  else { fail++; results.push(`  ✗ ${name}${detail ? ' — ' + detail : ''}`); }
}

function skipped(name, reason) {
  skip++; results.push(`  ○ ${name} — ${reason}`);
}

// ============================================================================
// 1. tx_explain.js — hardcoded keys removed, /stats requires admin
// ============================================================================
async function testTxExplain() {
  results.push('\n[tx_explain.js]');

  // /stats without admin key should 401
  const r1 = await req('GET', '/tx-explain/stats');
  test('GET /tx-explain/stats without auth → 401', r1.status === 401);

  // /stats with wrong key should 401
  const r2 = await req('GET', '/tx-explain/stats', { headers: { 'X-Admin-Key': 'wrong' } });
  test('GET /tx-explain/stats with bad key → 401', r2.status === 401);

  // Normal endpoint still works (invalid hash → 400)
  const r3 = await req('GET', '/tx-explain/ZZZZ');
  test('GET /tx-explain/:hash validation still works', r3.status === 400);

  // Valid hash format should not crash (may timeout to AI provider)
  const r4 = await req('GET', '/tx-explain/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA');
  test('GET /tx-explain/:hash with valid format does not crash', [200, 404, 500, 502, 503].includes(r4.status));
}

// ============================================================================
// 2. faucet.js — seed from env var, 503 when not configured
// ============================================================================
async function testFaucet() {
  results.push('\n[faucet.js]');

  // GET / should work regardless
  const r1 = await req('GET', '/faucet/');
  test('GET /faucet/ returns status', r1.data && typeof r1.data.address === 'string');

  // POST / without FAUCET_WALLET_SEED should 503
  const r2 = await req('POST', '/faucet/', { body: { destination: 'rPT1Sjq2YGrBMTttX4GZHjKu9dyfzbpAYe' } });
  // If seed not in env → 503. If seed IS in env → could be 200/429/500
  test('POST /faucet/ responds (503 if unconfigured, else functional)',
    [200, 429, 500, 503].includes(r2.status));

  // Invalid destination still rejected (503 if seed not configured, 400 if configured)
  const r3 = await req('POST', '/faucet/', { body: { destination: 'notanaddress' } });
  test('POST /faucet/ rejects invalid address or unconfigured', [400, 503].includes(r3.status));
}

// ============================================================================
// 3. user.js — shell injection fix, Stripe webhook, auth on mutations
// ============================================================================
async function testUser() {
  results.push('\n[user.js]');
  const testAddr = 'rPT1Sjq2YGrBMTttX4GZHjKu9dyfzbpAYe';

  // display-badge without auth headers → 401
  const r1 = await req('PUT', `/user/${testAddr}/display-badge`, { body: { badge: null } });
  test('PUT /user/:account/display-badge without auth → 401', r1.status === 401);

  // avatar without auth → 401
  const r2 = await req('PUT', `/user/${testAddr}/avatar`, {
    body: { nftId: 'A'.repeat(64) }
  });
  test('PUT /user/:account/avatar without auth → 401', r2.status === 401);

  // POST labels without auth → 401
  const r3 = await req('POST', `/user/${testAddr}/labels`, {
    body: { wallet: 'rN7n3473SaZBCG4dFL83w7a1RXtXtbk2D9', label: 'test' }
  });
  test('POST /user/:account/labels without auth → 401', r3.status === 401);

  // DELETE labels without auth → 401
  const r4 = await req('DELETE', `/user/${testAddr}/labels/rN7n3473SaZBCG4dFL83w7a1RXtXtbk2D9`);
  test('DELETE /user/:account/labels/:wallet without auth → 401', r4.status === 401);

  // Wrong wallet in auth header → 401
  const r5 = await req('PUT', `/user/${testAddr}/display-badge`, {
    body: { badge: null },
    headers: { 'x-wallet': 'rDifferentWallet123456789012345', 'x-timestamp': String(Date.now()), 'x-signature': 'fake', 'x-public-key': 'fake' }
  });
  test('PUT /display-badge with mismatched wallet → 401', r5.status === 401);

  // Stripe webhook forgery (no secret configured) → 503
  const r6 = await req('POST', '/user/tier/stripe/webhook', {
    body: { type: 'checkout.session.completed', data: { object: { metadata: { address: testAddr, tier: 'vip' } } } }
  });
  test('POST /user/tier/stripe/webhook forgery blocked', [400, 503].includes(r6.status));

  // GET /:account still works (read-only, no auth needed)
  const r7 = await req('GET', `/user/${testAddr}`);
  test('GET /user/:account still works', [200, 404].includes(r7.status));

  // GET /:account/badges still works
  const r8 = await req('GET', `/user/${testAddr}/badges`);
  test('GET /user/:account/badges still works', [200, 404].includes(r8.status));

  // GET /:account/labels still works (read-only)
  const r9 = await req('GET', `/user/${testAddr}/labels`);
  test('GET /user/:account/labels still works', r9.status === 200);
}

// ============================================================================
// 4. keys.js — Stripe webhook forgery
// ============================================================================
async function testKeys() {
  results.push('\n[keys.js]');

  // Stripe webhook forgery attempt
  const r1 = await req('POST', '/keys/stripe/webhook', {
    body: {
      type: 'checkout.session.completed',
      data: { object: { metadata: { wallet: 'rTest', purchaseType: 'credits', credits: '999999' } } }
    }
  });
  test('POST /keys/stripe/webhook forgery blocked', [400, 503].includes(r1.status));

  // GET /keys/:wallet still works (read-only)
  const r2 = await req('GET', '/keys/rPT1Sjq2YGrBMTttX4GZHjKu9dyfzbpAYe');
  test('GET /keys/:wallet still works', [200, 404].includes(r2.status));
}

// ============================================================================
// 5. account.js — NoSQL injection on POST /balance
// ============================================================================
async function testAccount() {
  results.push('\n[account.js]');

  // Valid addresses work
  const r1 = await req('POST', '/account/balance', {
    body: { accounts: ['rPT1Sjq2YGrBMTttX4GZHjKu9dyfzbpAYe'] }
  });
  test('POST /account/balance with valid addresses works', r1.data?.success === true || r1.status === 200);

  // NoSQL injection with $gt object → filtered out → ERR_INVALID_ACCOUNTS
  const r2 = await req('POST', '/account/balance', {
    body: { accounts: [{ '$gt': '' }] }
  });
  test('POST /account/balance blocks $gt injection', r2.status === 400 && r2.data?.error === 'ERR_INVALID_ACCOUNTS');

  // NoSQL injection with $ne → filtered
  const r3 = await req('POST', '/account/balance', {
    body: { accounts: [{ '$ne': null }] }
  });
  test('POST /account/balance blocks $ne injection', r3.status === 400);

  // Mixed valid + invalid → only valid ones pass through
  const r4 = await req('POST', '/account/balance', {
    body: { accounts: ['rPT1Sjq2YGrBMTttX4GZHjKu9dyfzbpAYe', 123, { '$gt': '' }, 'not-an-address'] }
  });
  test('POST /account/balance filters non-string/non-address entries', r4.data?.success === true);

  // Empty after filter → 400
  const r5 = await req('POST', '/account/balance', {
    body: { accounts: [123, null, { '$in': ['a'] }] }
  });
  test('POST /account/balance rejects all-invalid array', r5.status === 400);

  // Non-array → 400
  const r6 = await req('POST', '/account/balance', {
    body: { accounts: 'rPT1Sjq2YGrBMTttX4GZHjKu9dyfzbpAYe' }
  });
  test('POST /account/balance rejects non-array', r6.status === 400);

  // GET /account/balance/:account still works
  const r7 = await req('GET', '/account/balance/rPT1Sjq2YGrBMTttX4GZHjKu9dyfzbpAYe');
  test('GET /account/balance/:account still works', [200, 500].includes(r7.status));
}

// ============================================================================
// 6. chat.js — POST /read auth
// ============================================================================
async function testChat() {
  results.push('\n[chat.js]');

  // POST /chat/read without auth → 401
  const r1 = await req('POST', '/chat/read', {
    body: { wallet: 'rPT1Sjq2YGrBMTttX4GZHjKu9dyfzbpAYe' }
  });
  test('POST /chat/read without auth → 401', r1.status === 401);

  // POST /chat/read with invalid key → 401
  const r2 = await req('POST', '/chat/read', {
    body: { wallet: 'rPT1Sjq2YGrBMTttX4GZHjKu9dyfzbpAYe' },
    headers: { 'X-Api-Key': 'xrpl_invalidkey12345678' }
  });
  test('POST /chat/read with invalid key → 401', r2.status === 401);

  // POST /chat/read with bad wallet format → 400
  const r3 = await req('POST', '/chat/read', { body: { wallet: 'bad' } });
  test('POST /chat/read rejects bad wallet format', r3.status === 400);
}

// ============================================================================
// 7. referral.js — auth on mutations
// ============================================================================
async function testReferral() {
  results.push('\n[referral.js]');
  const testAddr = 'rPT1Sjq2YGrBMTttX4GZHjKu9dyfzbpAYe';

  // PUT /:address/code without auth → 401
  const r1 = await req('PUT', `/referral/${testAddr}/code`, { body: { referralCode: 'testcode' } });
  test('PUT /referral/:address/code without auth → 401', r1.status === 401);

  // PUT /:address/tier without auth → 401
  const r2 = await req('PUT', `/referral/${testAddr}/tier`, { body: { tier: 'Corporal' } });
  test('PUT /referral/:address/tier without auth → 401', r2.status === 401);

  // POST /:address/sync without auth → 401
  const r3 = await req('POST', `/referral/${testAddr}/sync`);
  test('POST /referral/:address/sync without auth → 401', r3.status === 401);

  // Read-only endpoints still work
  const r4 = await req('GET', `/referral/${testAddr}`);
  test('GET /referral/:address still works', [200, 404].includes(r4.status));

  const r5 = await req('GET', '/referral/meta/tiers');
  test('GET /referral/meta/tiers still works', r5.data?.success === true);

  const r6 = await req('GET', '/referral/leaderboard/recruits?limit=5');
  test('GET /referral/leaderboard still works', r6.data?.success === true);
}

// ============================================================================
// 8. verify.js — already fixed (sanity check)
// ============================================================================
async function testVerify() {
  results.push('\n[verify.js]');

  // Stripe webhook forgery
  const r1 = await req('POST', '/verify/stripe/webhook', {
    body: { type: 'checkout.session.completed', data: { object: { metadata: { type: 'token', id: 'test', tier: '2' } } } }
  });
  test('POST /verify/stripe/webhook forgery blocked', [400, 503].includes(r1.status));

  // Pricing endpoint still works
  const r2 = await req('GET', '/verify/pricing');
  test('GET /verify/pricing still works', r2.data?.success === true);
}

// ============================================================================
// 9. Cross-cutting: shell injection payloads
// ============================================================================
async function testShellInjection() {
  results.push('\n[Shell Injection Vectors]');

  // user.js curlPost is used by tier/purchase which calls MAINNET_RPC
  // We can't directly trigger it without a valid flow, but we test that
  // payloads with single quotes don't cause crashes
  const payload = "test'; echo PWNED; '";

  // POST /verify/request with shell chars in id
  const r1 = await req('POST', '/verify/request', {
    body: { type: 'token', id: payload, tier: 4 }
  });
  test('Shell chars in verify/request id → safe (404 not crash)', [400, 404].includes(r1.status));

  // POST /verify/confirm with shell chars in txHash
  const r2 = await req('POST', '/verify/confirm', { body: { txHash: payload } });
  test('Shell chars in verify/confirm txHash → safe', [400, 500].includes(r2.status));
}

// ============================================================================
// MAIN
// ============================================================================
async function main() {
  console.log(`\nFinal Security Audit — ${BASE}\n${'='.repeat(50)}`);

  try { await testTxExplain(); } catch (e) { results.push(`  ✗ tx_explain CRASH: ${e.message}`); fail++; }
  try { await testFaucet(); } catch (e) { results.push(`  ✗ faucet CRASH: ${e.message}`); fail++; }
  try { await testUser(); } catch (e) { results.push(`  ✗ user CRASH: ${e.message}`); fail++; }
  try { await testKeys(); } catch (e) { results.push(`  ✗ keys CRASH: ${e.message}`); fail++; }
  try { await testAccount(); } catch (e) { results.push(`  ✗ account CRASH: ${e.message}`); fail++; }
  try { await testChat(); } catch (e) { results.push(`  ✗ chat CRASH: ${e.message}`); fail++; }
  try { await testReferral(); } catch (e) { results.push(`  ✗ referral CRASH: ${e.message}`); fail++; }
  try { await testVerify(); } catch (e) { results.push(`  ✗ verify CRASH: ${e.message}`); fail++; }
  try { await testShellInjection(); } catch (e) { results.push(`  ✗ shell injection CRASH: ${e.message}`); fail++; }

  console.log(results.join('\n'));
  console.log(`\n${'='.repeat(50)}`);
  console.log(`PASS: ${pass}  FAIL: ${fail}  SKIP: ${skip}  TOTAL: ${pass + fail + skip}`);
  console.log(fail === 0 ? '\nAll tests passed.' : `\n${fail} test(s) failed!`);
  process.exit(fail > 0 ? 1 : 0);
}

main().catch(e => { console.error('Fatal:', e); process.exit(2); });
